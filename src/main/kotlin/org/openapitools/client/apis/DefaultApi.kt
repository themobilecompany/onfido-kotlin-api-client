/**
* Onfido API
* The Onfido API is used to submit check requests.
*
* OpenAPI spec version: 2.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.Applicant
import org.openapitools.client.models.ApplicantsList
import org.openapitools.client.models.Check
import org.openapitools.client.models.CheckWithReportIds
import org.openapitools.client.models.ChecksList
import org.openapitools.client.models.Document
import org.openapitools.client.models.DocumentsList
import org.openapitools.client.models.Error
import org.openapitools.client.models.GenericAddressesList
import org.openapitools.client.models.LivePhoto
import org.openapitools.client.models.LivePhotosList
import org.openapitools.client.models.LiveVideo
import org.openapitools.client.models.LiveVideosList
import org.openapitools.client.models.Report
import org.openapitools.client.models.ReportTypeGroup
import org.openapitools.client.models.ReportTypeGroupsList
import org.openapitools.client.models.ReportsList
import org.openapitools.client.models.Webhook
import org.openapitools.client.models.WebhooksList

import org.openapitools.client.infrastructure.*

class DefaultApi(basePath: kotlin.String = "https://api.onfido.com/v2") : ApiClient(basePath) {

    /**
    * This endpoint is for cancelling individual paused reports.
    * 
    * @param checkId  
    * @param reportId  
    * @return void
    */
    fun cancelReport(checkId: kotlin.String, reportId: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/checks/{check_id}/reports/{report_id}/cancel".replace("{"+"check_id"+"}", "$checkId").replace("{"+"report_id"+"}", "$reportId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create Applicant
    * 
    * @param applicant  
    * @return Applicant
    */
    @Suppress("UNCHECKED_CAST")
    fun createApplicant(applicant: Applicant) : Applicant {
        val localVariableBody: kotlin.Any? = applicant
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/applicants",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Applicant>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Applicant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a check
    * 
    * @param applicantId  
    * @param check  
    * @return Check
    */
    @Suppress("UNCHECKED_CAST")
    fun createCheck(applicantId: kotlin.String, check: Check) : Check {
        val localVariableBody: kotlin.Any? = check
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/applicants/{applicant_id}/checks".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Check>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Check
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a webhook
    * 
    * @param webhook  
    * @return Webhook
    */
    @Suppress("UNCHECKED_CAST")
    fun createWebhook(webhook: Webhook) : Webhook {
        val localVariableBody: kotlin.Any? = webhook
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/webhooks",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Webhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Webhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Delete Applicant
    * 
    * @param applicantId  
    * @return void
    */
    fun destroyApplicant(applicantId: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/applicants/{applicant_id}".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Download a documents raw data
    * 
    * @param applicantId  
    * @param documentId  
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun downloadDocument(applicantId: kotlin.String, documentId: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}/documents/{document_id}/download".replace("{"+"applicant_id"+"}", "$applicantId").replace("{"+"document_id"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Download live photo
    * Live photos are downloaded using this endpoint.
    * @param livePhotoId The live photo’s unique identifier. 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun downloadLivePhoto(livePhotoId: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_photos/{live_photo_id}/download".replace("{"+"live_photo_id"+"}", "$livePhotoId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Download live video
    * Live videos are downloaded using this endpoint.
    * @param liveVideoId The live video’s unique identifier. 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun downloadLiveVideo(liveVideoId: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_videos/{live_video_id}/download".replace("{"+"live_video_id"+"}", "$liveVideoId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Search for addresses by postcode
    * 
    * @param postcode  
    * @return GenericAddressesList
    */
    @Suppress("UNCHECKED_CAST")
    fun findAddresses(postcode: kotlin.String) : GenericAddressesList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("postcode" to listOf("$postcode"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/addresses/pick",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<GenericAddressesList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GenericAddressesList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve Applicant
    * 
    * @param applicantId  
    * @return Applicant
    */
    @Suppress("UNCHECKED_CAST")
    fun findApplicant(applicantId: kotlin.String) : Applicant {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Applicant>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Applicant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve a Check
    * 
    * @param applicantId  
    * @param checkId  
    * @return CheckWithReportIds
    */
    @Suppress("UNCHECKED_CAST")
    fun findCheck(applicantId: kotlin.String, checkId: kotlin.String) : CheckWithReportIds {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}/checks/{check_id}".replace("{"+"applicant_id"+"}", "$applicantId").replace("{"+"check_id"+"}", "$checkId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<CheckWithReportIds>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CheckWithReportIds
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * A single document can be retrieved by calling this endpoint with the document’s unique identifier.
    * 
    * @param applicantId  
    * @param documentId  
    * @return Document
    */
    @Suppress("UNCHECKED_CAST")
    fun findDocument(applicantId: kotlin.String, documentId: kotlin.String) : Document {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}/documents/{document_id}".replace("{"+"applicant_id"+"}", "$applicantId").replace("{"+"document_id"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Document>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Document
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve live photo
    * 
    * @param livePhotoId The live photo’s unique identifier. 
    * @return LivePhoto
    */
    @Suppress("UNCHECKED_CAST")
    fun findLivePhoto(livePhotoId: kotlin.String) : LivePhoto {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_photos/{live_photo_id}".replace("{"+"live_photo_id"+"}", "$livePhotoId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<LivePhoto>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LivePhoto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve live video
    * 
    * @param liveVideoId The live video’s unique identifier. 
    * @return LiveVideo
    */
    @Suppress("UNCHECKED_CAST")
    fun findLiveVideo(liveVideoId: kotlin.String) : LiveVideo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_videos/{live_video_id}".replace("{"+"live_video_id"+"}", "$liveVideoId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<LiveVideo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LiveVideo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * A single report can be retrieved using this endpoint with the corresponding unique identifier.
    * 
    * @param checkId  
    * @param reportId  
    * @return Report
    */
    @Suppress("UNCHECKED_CAST")
    fun findReport(checkId: kotlin.String, reportId: kotlin.String) : Report {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/checks/{check_id}/reports/{report_id}".replace("{"+"check_id"+"}", "$checkId").replace("{"+"report_id"+"}", "$reportId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Report>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Report
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve single report type group object
    * 
    * @param reportTypeGroupId  
    * @return ReportTypeGroup
    */
    @Suppress("UNCHECKED_CAST")
    fun findReportTypeGroup(reportTypeGroupId: kotlin.String) : ReportTypeGroup {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/report_type_groups/{report_type_group_id}".replace("{"+"report_type_group_id"+"}", "$reportTypeGroupId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ReportTypeGroup>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ReportTypeGroup
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve a Webhook
    * 
    * @param webhookId  
    * @return Webhook
    */
    @Suppress("UNCHECKED_CAST")
    fun findWebhook(webhookId: kotlin.String) : Webhook {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/webhooks/{webhook_id}".replace("{"+"webhook_id"+"}", "$webhookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Webhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Webhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List Applicants
    * 
    * @param page The page to return. The first page is &#x60;page&#x3D;1&#x60; (optional, default to 1)
    * @param perPage The number of objects per page. (optional, default to 20)
    * @param includeDeleted Whether to also include applicants scheduled for deletion. (optional, default to false)
    * @return ApplicantsList
    */
    @Suppress("UNCHECKED_CAST")
    fun listApplicants(page: kotlin.Int, perPage: kotlin.Int, includeDeleted: kotlin.Boolean) : ApplicantsList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "per_page" to listOf("$perPage"), "include_deleted" to listOf("$includeDeleted"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ApplicantsList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ApplicantsList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve Checks
    * 
    * @param applicantId  
    * @param page The page to return. The first page is &#x60;page&#x3D;1&#x60;. (optional, default to 1)
    * @param perPage The number of objects per page. (optional, default to 20)
    * @return ChecksList
    */
    @Suppress("UNCHECKED_CAST")
    fun listChecks(applicantId: kotlin.String, page: kotlin.Int, perPage: kotlin.Int) : ChecksList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "per_page" to listOf("$perPage"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}/checks".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChecksList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChecksList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List documents
    * All documents belonging to an applicant can be listed from this endpoint
    * @param applicantId  
    * @return DocumentsList
    */
    @Suppress("UNCHECKED_CAST")
    fun listDocuments(applicantId: kotlin.String) : DocumentsList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/applicants/{applicant_id}/documents".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<DocumentsList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DocumentsList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List live photos
    * 
    * @param applicantId The id of the applicant the live photos belong to. 
    * @return LivePhotosList
    */
    @Suppress("UNCHECKED_CAST")
    fun listLivePhotos(applicantId: kotlin.String) : LivePhotosList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("applicant_id" to listOf("$applicantId"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_photos",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<LivePhotosList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LivePhotosList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List live videos
    * 
    * @param applicantId The id of the applicant the live videos belong to. 
    * @return LiveVideosList
    */
    @Suppress("UNCHECKED_CAST")
    fun listLiveVideos(applicantId: kotlin.String) : LiveVideosList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("applicant_id" to listOf("$applicantId"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/live_videos",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<LiveVideosList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LiveVideosList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Retrieve all report type groups
    * 
    * @return ReportTypeGroupsList
    */
    @Suppress("UNCHECKED_CAST")
    fun listReportTypeGroups() : ReportTypeGroupsList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/report_type_groups",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ReportTypeGroupsList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ReportTypeGroupsList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * All the reports belonging to a particular check can be listed from this endpoint.
    * 
    * @param checkId  
    * @return ReportsList
    */
    @Suppress("UNCHECKED_CAST")
    fun listReports(checkId: kotlin.String) : ReportsList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/checks/{check_id}/reports".replace("{"+"check_id"+"}", "$checkId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ReportsList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ReportsList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List webhooks
    * 
    * @return WebhooksList
    */
    @Suppress("UNCHECKED_CAST")
    fun listWebhooks() : WebhooksList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/webhooks",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<WebhooksList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as WebhooksList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Restore Applicant
    * 
    * @param applicantId  
    * @return void
    */
    fun restoreApplicant(applicantId: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/applicants/{applicant_id}/restore".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Resume a Check
    * 
    * @param checkId  
    * @return void
    */
    fun resumeCheck(checkId: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/checks/{check_id}/resume".replace("{"+"check_id"+"}", "$checkId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * This endpoint is for resuming individual paused reports.
    * 
    * @param checkId  
    * @param reportId  
    * @return void
    */
    fun resumeReport(checkId: kotlin.String, reportId: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/checks/{check_id}/reports/{report_id}/resume".replace("{"+"check_id"+"}", "$checkId").replace("{"+"report_id"+"}", "$reportId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update Applicant
    * Allows updating of an applicant’s information before any checks are created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
    * @param applicantId  
    * @param applicant  
    * @return Applicant
    */
    @Suppress("UNCHECKED_CAST")
    fun updateApplicant(applicantId: kotlin.String, applicant: Applicant) : Applicant {
        val localVariableBody: kotlin.Any? = applicant
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/applicants/{applicant_id}".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Applicant>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Applicant
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Upload a document
    * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
    * @param applicantId  
    * @param type The type of document. 
    * @param file The file to be uploaded. 
    * @param side Either the &#x60;front&#x60; or &#x60;back&#x60; of the document. (optional, default to null)
    * @return Document
    */
    @Suppress("UNCHECKED_CAST")
    fun uploadDocument(applicantId: kotlin.String, type: kotlin.String, file: java.io.File, side: kotlin.String) : Document {
        val localVariableBody: kotlin.Any? = mapOf("type" to "$type", "side" to "$side", "file" to "$file")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/applicants/{applicant_id}/documents".replace("{"+"applicant_id"+"}", "$applicantId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Document>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Document
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Upload live photo
    * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
    * @param applicantId  
    * @param file The file to be uploaded. 
    * @param advancedValidation Validates that the live photo contains exactly one face. (optional, default to true)
    * @return LivePhoto
    */
    @Suppress("UNCHECKED_CAST")
    fun uploadLivePhoto(applicantId: kotlin.String, file: java.io.File, advancedValidation: kotlin.Boolean) : LivePhoto {
        val localVariableBody: kotlin.Any? = mapOf("applicant_id" to "$applicantId", "file" to "$file", "advanced_validation" to "$advancedValidation")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/live_photos",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<LivePhoto>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as LivePhoto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
